// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"bosh-softlayer-cpi/softlayer/client"
	"sync"
	"time"

	"github.com/softlayer/softlayer-go/datatypes"
)

type FakeClient struct {
	CancelInstanceStub        func(id int) error
	cancelInstanceMutex       sync.RWMutex
	cancelInstanceArgsForCall []struct {
		id int
	}
	cancelInstanceReturns struct {
		result1 error
	}
	cancelInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	CreateInstanceStub        func(template *datatypes.Virtual_Guest) (datatypes.Virtual_Guest, error)
	createInstanceMutex       sync.RWMutex
	createInstanceArgsForCall []struct {
		template *datatypes.Virtual_Guest
	}
	createInstanceReturns struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	createInstanceReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	EditInstanceStub        func(id int, template *datatypes.Virtual_Guest) (bool, error)
	editInstanceMutex       sync.RWMutex
	editInstanceArgsForCall []struct {
		id       int
		template *datatypes.Virtual_Guest
	}
	editInstanceReturns struct {
		result1 bool
		result2 error
	}
	editInstanceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetInstanceStub        func(id int, mask string) (datatypes.Virtual_Guest, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		id   int
		mask string
	}
	getInstanceReturns struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	GetInstanceByPrimaryBackendIpAddressStub        func(ip string) (datatypes.Virtual_Guest, error)
	getInstanceByPrimaryBackendIpAddressMutex       sync.RWMutex
	getInstanceByPrimaryBackendIpAddressArgsForCall []struct {
		ip string
	}
	getInstanceByPrimaryBackendIpAddressReturns struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	getInstanceByPrimaryBackendIpAddressReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	GetInstanceByPrimaryIpAddressStub        func(ip string) (datatypes.Virtual_Guest, error)
	getInstanceByPrimaryIpAddressMutex       sync.RWMutex
	getInstanceByPrimaryIpAddressArgsForCall []struct {
		ip string
	}
	getInstanceByPrimaryIpAddressReturns struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	getInstanceByPrimaryIpAddressReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}
	RebootInstanceStub        func(id int, soft bool, hard bool) error
	rebootInstanceMutex       sync.RWMutex
	rebootInstanceArgsForCall []struct {
		id   int
		soft bool
		hard bool
	}
	rebootInstanceReturns struct {
		result1 error
	}
	rebootInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadInstanceStub        func(id int, stemcellId int, sshKeyIds []int) (string, error)
	reloadInstanceMutex       sync.RWMutex
	reloadInstanceArgsForCall []struct {
		id         int
		stemcellId int
		sshKeyIds  []int
	}
	reloadInstanceReturns struct {
		result1 string
		result2 error
	}
	reloadInstanceReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UpgradeInstanceStub        func(id int, cpu int, memory int, network int, privateCPU bool, additional_diskSize int) (datatypes.Container_Product_Order_Receipt, error)
	upgradeInstanceMutex       sync.RWMutex
	upgradeInstanceArgsForCall []struct {
		id                  int
		cpu                 int
		memory              int
		network             int
		privateCPU          bool
		additional_diskSize int
	}
	upgradeInstanceReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	upgradeInstanceReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	WaitInstanceUntilReadyStub        func(id int, until time.Time) error
	waitInstanceUntilReadyMutex       sync.RWMutex
	waitInstanceUntilReadyArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceUntilReadyReturns struct {
		result1 error
	}
	waitInstanceUntilReadyReturnsOnCall map[int]struct {
		result1 error
	}
	WaitInstanceHasActiveTransactionStub        func(id int, until time.Time) error
	waitInstanceHasActiveTransactionMutex       sync.RWMutex
	waitInstanceHasActiveTransactionArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceHasActiveTransactionReturns struct {
		result1 error
	}
	waitInstanceHasActiveTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	WaitInstanceHasNoneActiveTransactionStub        func(id int, until time.Time) error
	waitInstanceHasNoneActiveTransactionMutex       sync.RWMutex
	waitInstanceHasNoneActiveTransactionArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceHasNoneActiveTransactionReturns struct {
		result1 error
	}
	waitInstanceHasNoneActiveTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	SetTagsStub        func(id int, tags string) error
	setTagsMutex       sync.RWMutex
	setTagsArgsForCall []struct {
		id   int
		tags string
	}
	setTagsReturns struct {
		result1 error
	}
	setTagsReturnsOnCall map[int]struct {
		result1 error
	}
	AttachSecondDiskToInstanceStub        func(id int, diskSize int) error
	attachSecondDiskToInstanceMutex       sync.RWMutex
	attachSecondDiskToInstanceArgsForCall []struct {
		id       int
		diskSize int
	}
	attachSecondDiskToInstanceReturns struct {
		result1 error
	}
	attachSecondDiskToInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	GetInstanceAllowedHostStub        func(id int) (datatypes.Network_Storage_Allowed_Host, error)
	getInstanceAllowedHostMutex       sync.RWMutex
	getInstanceAllowedHostArgsForCall []struct {
		id int
	}
	getInstanceAllowedHostReturns struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	getInstanceAllowedHostReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	AuthorizeHostToVolumeStub        func(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) error
	authorizeHostToVolumeMutex       sync.RWMutex
	authorizeHostToVolumeArgsForCall []struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}
	authorizeHostToVolumeReturns struct {
		result1 error
	}
	authorizeHostToVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	DeauthorizeHostToVolumeStub        func(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) error
	deauthorizeHostToVolumeMutex       sync.RWMutex
	deauthorizeHostToVolumeArgsForCall []struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}
	deauthorizeHostToVolumeReturns struct {
		result1 error
	}
	deauthorizeHostToVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateVolumeStub        func(location string, size int, iops int) (datatypes.Network_Storage, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		location string
		size     int
		iops     int
	}
	createVolumeReturns struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	OrderBlockVolumeStub        func(storageType string, location string, size int, iops int) (datatypes.Container_Product_Order_Receipt, error)
	orderBlockVolumeMutex       sync.RWMutex
	orderBlockVolumeArgsForCall []struct {
		storageType string
		location    string
		size        int
		iops        int
	}
	orderBlockVolumeReturns struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderBlockVolumeReturnsOnCall map[int]struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}
	CancelBlockVolumeStub        func(volumeId int, reason string, immedicate bool) error
	cancelBlockVolumeMutex       sync.RWMutex
	cancelBlockVolumeArgsForCall []struct {
		volumeId   int
		reason     string
		immedicate bool
	}
	cancelBlockVolumeReturns struct {
		result1 error
	}
	cancelBlockVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	GetBlockVolumeDetailsStub        func(volumeId int, mask string) (datatypes.Network_Storage, error)
	getBlockVolumeDetailsMutex       sync.RWMutex
	getBlockVolumeDetailsArgsForCall []struct {
		volumeId int
		mask     string
	}
	getBlockVolumeDetailsReturns struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	getBlockVolumeDetailsReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	GetImageStub        func(imageId int, mask string) (datatypes.Virtual_Guest_Block_Device_Template_Group, error)
	getImageMutex       sync.RWMutex
	getImageArgsForCall []struct {
		imageId int
		mask    string
	}
	getImageReturns struct {
		result1 datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 error
	}
	getImageReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 error
	}
	GetVlanStub        func(id int, mask string) (datatypes.Network_Vlan, error)
	getVlanMutex       sync.RWMutex
	getVlanArgsForCall []struct {
		id   int
		mask string
	}
	getVlanReturns struct {
		result1 datatypes.Network_Vlan
		result2 error
	}
	getVlanReturnsOnCall map[int]struct {
		result1 datatypes.Network_Vlan
		result2 error
	}
	GetAllowedHostCredentialStub        func(id int) (datatypes.Network_Storage_Allowed_Host, error)
	getAllowedHostCredentialMutex       sync.RWMutex
	getAllowedHostCredentialArgsForCall []struct {
		id int
	}
	getAllowedHostCredentialReturns struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	getAllowedHostCredentialReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}
	GetAllowedNetworkStorageStub        func(id int) ([]string, error)
	getAllowedNetworkStorageMutex       sync.RWMutex
	getAllowedNetworkStorageArgsForCall []struct {
		id int
	}
	getAllowedNetworkStorageReturns struct {
		result1 []string
		result2 error
	}
	getAllowedNetworkStorageReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CancelInstance(id int) error {
	fake.cancelInstanceMutex.Lock()
	ret, specificReturn := fake.cancelInstanceReturnsOnCall[len(fake.cancelInstanceArgsForCall)]
	fake.cancelInstanceArgsForCall = append(fake.cancelInstanceArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("CancelInstance", []interface{}{id})
	fake.cancelInstanceMutex.Unlock()
	if fake.CancelInstanceStub != nil {
		return fake.CancelInstanceStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cancelInstanceReturns.result1
}

func (fake *FakeClient) CancelInstanceCallCount() int {
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	return len(fake.cancelInstanceArgsForCall)
}

func (fake *FakeClient) CancelInstanceArgsForCall(i int) int {
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	return fake.cancelInstanceArgsForCall[i].id
}

func (fake *FakeClient) CancelInstanceReturns(result1 error) {
	fake.CancelInstanceStub = nil
	fake.cancelInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CancelInstanceReturnsOnCall(i int, result1 error) {
	fake.CancelInstanceStub = nil
	if fake.cancelInstanceReturnsOnCall == nil {
		fake.cancelInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateInstance(template *datatypes.Virtual_Guest) (datatypes.Virtual_Guest, error) {
	fake.createInstanceMutex.Lock()
	ret, specificReturn := fake.createInstanceReturnsOnCall[len(fake.createInstanceArgsForCall)]
	fake.createInstanceArgsForCall = append(fake.createInstanceArgsForCall, struct {
		template *datatypes.Virtual_Guest
	}{template})
	fake.recordInvocation("CreateInstance", []interface{}{template})
	fake.createInstanceMutex.Unlock()
	if fake.CreateInstanceStub != nil {
		return fake.CreateInstanceStub(template)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createInstanceReturns.result1, fake.createInstanceReturns.result2
}

func (fake *FakeClient) CreateInstanceCallCount() int {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return len(fake.createInstanceArgsForCall)
}

func (fake *FakeClient) CreateInstanceArgsForCall(i int) *datatypes.Virtual_Guest {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return fake.createInstanceArgsForCall[i].template
}

func (fake *FakeClient) CreateInstanceReturns(result1 datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceStub = nil
	fake.createInstanceReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateInstanceReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceStub = nil
	if fake.createInstanceReturnsOnCall == nil {
		fake.createInstanceReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.createInstanceReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) EditInstance(id int, template *datatypes.Virtual_Guest) (bool, error) {
	fake.editInstanceMutex.Lock()
	ret, specificReturn := fake.editInstanceReturnsOnCall[len(fake.editInstanceArgsForCall)]
	fake.editInstanceArgsForCall = append(fake.editInstanceArgsForCall, struct {
		id       int
		template *datatypes.Virtual_Guest
	}{id, template})
	fake.recordInvocation("EditInstance", []interface{}{id, template})
	fake.editInstanceMutex.Unlock()
	if fake.EditInstanceStub != nil {
		return fake.EditInstanceStub(id, template)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.editInstanceReturns.result1, fake.editInstanceReturns.result2
}

func (fake *FakeClient) EditInstanceCallCount() int {
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	return len(fake.editInstanceArgsForCall)
}

func (fake *FakeClient) EditInstanceArgsForCall(i int) (int, *datatypes.Virtual_Guest) {
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	return fake.editInstanceArgsForCall[i].id, fake.editInstanceArgsForCall[i].template
}

func (fake *FakeClient) EditInstanceReturns(result1 bool, result2 error) {
	fake.EditInstanceStub = nil
	fake.editInstanceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) EditInstanceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EditInstanceStub = nil
	if fake.editInstanceReturnsOnCall == nil {
		fake.editInstanceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.editInstanceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstance(id int, mask string) (datatypes.Virtual_Guest, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetInstance", []interface{}{id, mask})
	fake.getInstanceMutex.Unlock()
	if fake.GetInstanceStub != nil {
		return fake.GetInstanceStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getInstanceReturns.result1, fake.getInstanceReturns.result2
}

func (fake *FakeClient) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeClient) GetInstanceArgsForCall(i int) (int, string) {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return fake.getInstanceArgsForCall[i].id, fake.getInstanceArgsForCall[i].mask
}

func (fake *FakeClient) GetInstanceReturns(result1 datatypes.Virtual_Guest, result2 error) {
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 error) {
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddress(ip string) (datatypes.Virtual_Guest, error) {
	fake.getInstanceByPrimaryBackendIpAddressMutex.Lock()
	ret, specificReturn := fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall[len(fake.getInstanceByPrimaryBackendIpAddressArgsForCall)]
	fake.getInstanceByPrimaryBackendIpAddressArgsForCall = append(fake.getInstanceByPrimaryBackendIpAddressArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("GetInstanceByPrimaryBackendIpAddress", []interface{}{ip})
	fake.getInstanceByPrimaryBackendIpAddressMutex.Unlock()
	if fake.GetInstanceByPrimaryBackendIpAddressStub != nil {
		return fake.GetInstanceByPrimaryBackendIpAddressStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getInstanceByPrimaryBackendIpAddressReturns.result1, fake.getInstanceByPrimaryBackendIpAddressReturns.result2
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressCallCount() int {
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	return len(fake.getInstanceByPrimaryBackendIpAddressArgsForCall)
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressArgsForCall(i int) string {
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	return fake.getInstanceByPrimaryBackendIpAddressArgsForCall[i].ip
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressReturns(result1 datatypes.Virtual_Guest, result2 error) {
	fake.GetInstanceByPrimaryBackendIpAddressStub = nil
	fake.getInstanceByPrimaryBackendIpAddressReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 error) {
	fake.GetInstanceByPrimaryBackendIpAddressStub = nil
	if fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall == nil {
		fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddress(ip string) (datatypes.Virtual_Guest, error) {
	fake.getInstanceByPrimaryIpAddressMutex.Lock()
	ret, specificReturn := fake.getInstanceByPrimaryIpAddressReturnsOnCall[len(fake.getInstanceByPrimaryIpAddressArgsForCall)]
	fake.getInstanceByPrimaryIpAddressArgsForCall = append(fake.getInstanceByPrimaryIpAddressArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("GetInstanceByPrimaryIpAddress", []interface{}{ip})
	fake.getInstanceByPrimaryIpAddressMutex.Unlock()
	if fake.GetInstanceByPrimaryIpAddressStub != nil {
		return fake.GetInstanceByPrimaryIpAddressStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getInstanceByPrimaryIpAddressReturns.result1, fake.getInstanceByPrimaryIpAddressReturns.result2
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressCallCount() int {
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	return len(fake.getInstanceByPrimaryIpAddressArgsForCall)
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressArgsForCall(i int) string {
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	return fake.getInstanceByPrimaryIpAddressArgsForCall[i].ip
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressReturns(result1 datatypes.Virtual_Guest, result2 error) {
	fake.GetInstanceByPrimaryIpAddressStub = nil
	fake.getInstanceByPrimaryIpAddressReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 error) {
	fake.GetInstanceByPrimaryIpAddressStub = nil
	if fake.getInstanceByPrimaryIpAddressReturnsOnCall == nil {
		fake.getInstanceByPrimaryIpAddressReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.getInstanceByPrimaryIpAddressReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RebootInstance(id int, soft bool, hard bool) error {
	fake.rebootInstanceMutex.Lock()
	ret, specificReturn := fake.rebootInstanceReturnsOnCall[len(fake.rebootInstanceArgsForCall)]
	fake.rebootInstanceArgsForCall = append(fake.rebootInstanceArgsForCall, struct {
		id   int
		soft bool
		hard bool
	}{id, soft, hard})
	fake.recordInvocation("RebootInstance", []interface{}{id, soft, hard})
	fake.rebootInstanceMutex.Unlock()
	if fake.RebootInstanceStub != nil {
		return fake.RebootInstanceStub(id, soft, hard)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rebootInstanceReturns.result1
}

func (fake *FakeClient) RebootInstanceCallCount() int {
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	return len(fake.rebootInstanceArgsForCall)
}

func (fake *FakeClient) RebootInstanceArgsForCall(i int) (int, bool, bool) {
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	return fake.rebootInstanceArgsForCall[i].id, fake.rebootInstanceArgsForCall[i].soft, fake.rebootInstanceArgsForCall[i].hard
}

func (fake *FakeClient) RebootInstanceReturns(result1 error) {
	fake.RebootInstanceStub = nil
	fake.rebootInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RebootInstanceReturnsOnCall(i int, result1 error) {
	fake.RebootInstanceStub = nil
	if fake.rebootInstanceReturnsOnCall == nil {
		fake.rebootInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ReloadInstance(id int, stemcellId int, sshKeyIds []int) (string, error) {
	var sshKeyIdsCopy []int
	if sshKeyIds != nil {
		sshKeyIdsCopy = make([]int, len(sshKeyIds))
		copy(sshKeyIdsCopy, sshKeyIds)
	}
	fake.reloadInstanceMutex.Lock()
	ret, specificReturn := fake.reloadInstanceReturnsOnCall[len(fake.reloadInstanceArgsForCall)]
	fake.reloadInstanceArgsForCall = append(fake.reloadInstanceArgsForCall, struct {
		id         int
		stemcellId int
		sshKeyIds  []int
	}{id, stemcellId, sshKeyIdsCopy})
	fake.recordInvocation("ReloadInstance", []interface{}{id, stemcellId, sshKeyIdsCopy})
	fake.reloadInstanceMutex.Unlock()
	if fake.ReloadInstanceStub != nil {
		return fake.ReloadInstanceStub(id, stemcellId, sshKeyIds)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.reloadInstanceReturns.result1, fake.reloadInstanceReturns.result2
}

func (fake *FakeClient) ReloadInstanceCallCount() int {
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	return len(fake.reloadInstanceArgsForCall)
}

func (fake *FakeClient) ReloadInstanceArgsForCall(i int) (int, int, []int) {
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	return fake.reloadInstanceArgsForCall[i].id, fake.reloadInstanceArgsForCall[i].stemcellId, fake.reloadInstanceArgsForCall[i].sshKeyIds
}

func (fake *FakeClient) ReloadInstanceReturns(result1 string, result2 error) {
	fake.ReloadInstanceStub = nil
	fake.reloadInstanceReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ReloadInstanceReturnsOnCall(i int, result1 string, result2 error) {
	fake.ReloadInstanceStub = nil
	if fake.reloadInstanceReturnsOnCall == nil {
		fake.reloadInstanceReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.reloadInstanceReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpgradeInstance(id int, cpu int, memory int, network int, privateCPU bool, additional_diskSize int) (datatypes.Container_Product_Order_Receipt, error) {
	fake.upgradeInstanceMutex.Lock()
	ret, specificReturn := fake.upgradeInstanceReturnsOnCall[len(fake.upgradeInstanceArgsForCall)]
	fake.upgradeInstanceArgsForCall = append(fake.upgradeInstanceArgsForCall, struct {
		id                  int
		cpu                 int
		memory              int
		network             int
		privateCPU          bool
		additional_diskSize int
	}{id, cpu, memory, network, privateCPU, additional_diskSize})
	fake.recordInvocation("UpgradeInstance", []interface{}{id, cpu, memory, network, privateCPU, additional_diskSize})
	fake.upgradeInstanceMutex.Unlock()
	if fake.UpgradeInstanceStub != nil {
		return fake.UpgradeInstanceStub(id, cpu, memory, network, privateCPU, additional_diskSize)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.upgradeInstanceReturns.result1, fake.upgradeInstanceReturns.result2
}

func (fake *FakeClient) UpgradeInstanceCallCount() int {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return len(fake.upgradeInstanceArgsForCall)
}

func (fake *FakeClient) UpgradeInstanceArgsForCall(i int) (int, int, int, int, bool, int) {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return fake.upgradeInstanceArgsForCall[i].id, fake.upgradeInstanceArgsForCall[i].cpu, fake.upgradeInstanceArgsForCall[i].memory, fake.upgradeInstanceArgsForCall[i].network, fake.upgradeInstanceArgsForCall[i].privateCPU, fake.upgradeInstanceArgsForCall[i].additional_diskSize
}

func (fake *FakeClient) UpgradeInstanceReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.UpgradeInstanceStub = nil
	fake.upgradeInstanceReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpgradeInstanceReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.UpgradeInstanceStub = nil
	if fake.upgradeInstanceReturnsOnCall == nil {
		fake.upgradeInstanceReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.upgradeInstanceReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WaitInstanceUntilReady(id int, until time.Time) error {
	fake.waitInstanceUntilReadyMutex.Lock()
	ret, specificReturn := fake.waitInstanceUntilReadyReturnsOnCall[len(fake.waitInstanceUntilReadyArgsForCall)]
	fake.waitInstanceUntilReadyArgsForCall = append(fake.waitInstanceUntilReadyArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceUntilReady", []interface{}{id, until})
	fake.waitInstanceUntilReadyMutex.Unlock()
	if fake.WaitInstanceUntilReadyStub != nil {
		return fake.WaitInstanceUntilReadyStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceUntilReadyReturns.result1
}

func (fake *FakeClient) WaitInstanceUntilReadyCallCount() int {
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	return len(fake.waitInstanceUntilReadyArgsForCall)
}

func (fake *FakeClient) WaitInstanceUntilReadyArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	return fake.waitInstanceUntilReadyArgsForCall[i].id, fake.waitInstanceUntilReadyArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceUntilReadyReturns(result1 error) {
	fake.WaitInstanceUntilReadyStub = nil
	fake.waitInstanceUntilReadyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceUntilReadyReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceUntilReadyStub = nil
	if fake.waitInstanceUntilReadyReturnsOnCall == nil {
		fake.waitInstanceUntilReadyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceUntilReadyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasActiveTransaction(id int, until time.Time) error {
	fake.waitInstanceHasActiveTransactionMutex.Lock()
	ret, specificReturn := fake.waitInstanceHasActiveTransactionReturnsOnCall[len(fake.waitInstanceHasActiveTransactionArgsForCall)]
	fake.waitInstanceHasActiveTransactionArgsForCall = append(fake.waitInstanceHasActiveTransactionArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceHasActiveTransaction", []interface{}{id, until})
	fake.waitInstanceHasActiveTransactionMutex.Unlock()
	if fake.WaitInstanceHasActiveTransactionStub != nil {
		return fake.WaitInstanceHasActiveTransactionStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceHasActiveTransactionReturns.result1
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionCallCount() int {
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	return len(fake.waitInstanceHasActiveTransactionArgsForCall)
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	return fake.waitInstanceHasActiveTransactionArgsForCall[i].id, fake.waitInstanceHasActiveTransactionArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionReturns(result1 error) {
	fake.WaitInstanceHasActiveTransactionStub = nil
	fake.waitInstanceHasActiveTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceHasActiveTransactionStub = nil
	if fake.waitInstanceHasActiveTransactionReturnsOnCall == nil {
		fake.waitInstanceHasActiveTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceHasActiveTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransaction(id int, until time.Time) error {
	fake.waitInstanceHasNoneActiveTransactionMutex.Lock()
	ret, specificReturn := fake.waitInstanceHasNoneActiveTransactionReturnsOnCall[len(fake.waitInstanceHasNoneActiveTransactionArgsForCall)]
	fake.waitInstanceHasNoneActiveTransactionArgsForCall = append(fake.waitInstanceHasNoneActiveTransactionArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceHasNoneActiveTransaction", []interface{}{id, until})
	fake.waitInstanceHasNoneActiveTransactionMutex.Unlock()
	if fake.WaitInstanceHasNoneActiveTransactionStub != nil {
		return fake.WaitInstanceHasNoneActiveTransactionStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceHasNoneActiveTransactionReturns.result1
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionCallCount() int {
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	return len(fake.waitInstanceHasNoneActiveTransactionArgsForCall)
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	return fake.waitInstanceHasNoneActiveTransactionArgsForCall[i].id, fake.waitInstanceHasNoneActiveTransactionArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionReturns(result1 error) {
	fake.WaitInstanceHasNoneActiveTransactionStub = nil
	fake.waitInstanceHasNoneActiveTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceHasNoneActiveTransactionStub = nil
	if fake.waitInstanceHasNoneActiveTransactionReturnsOnCall == nil {
		fake.waitInstanceHasNoneActiveTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceHasNoneActiveTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SetTags(id int, tags string) error {
	fake.setTagsMutex.Lock()
	ret, specificReturn := fake.setTagsReturnsOnCall[len(fake.setTagsArgsForCall)]
	fake.setTagsArgsForCall = append(fake.setTagsArgsForCall, struct {
		id   int
		tags string
	}{id, tags})
	fake.recordInvocation("SetTags", []interface{}{id, tags})
	fake.setTagsMutex.Unlock()
	if fake.SetTagsStub != nil {
		return fake.SetTagsStub(id, tags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setTagsReturns.result1
}

func (fake *FakeClient) SetTagsCallCount() int {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	return len(fake.setTagsArgsForCall)
}

func (fake *FakeClient) SetTagsArgsForCall(i int) (int, string) {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	return fake.setTagsArgsForCall[i].id, fake.setTagsArgsForCall[i].tags
}

func (fake *FakeClient) SetTagsReturns(result1 error) {
	fake.SetTagsStub = nil
	fake.setTagsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SetTagsReturnsOnCall(i int, result1 error) {
	fake.SetTagsStub = nil
	if fake.setTagsReturnsOnCall == nil {
		fake.setTagsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTagsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AttachSecondDiskToInstance(id int, diskSize int) error {
	fake.attachSecondDiskToInstanceMutex.Lock()
	ret, specificReturn := fake.attachSecondDiskToInstanceReturnsOnCall[len(fake.attachSecondDiskToInstanceArgsForCall)]
	fake.attachSecondDiskToInstanceArgsForCall = append(fake.attachSecondDiskToInstanceArgsForCall, struct {
		id       int
		diskSize int
	}{id, diskSize})
	fake.recordInvocation("AttachSecondDiskToInstance", []interface{}{id, diskSize})
	fake.attachSecondDiskToInstanceMutex.Unlock()
	if fake.AttachSecondDiskToInstanceStub != nil {
		return fake.AttachSecondDiskToInstanceStub(id, diskSize)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachSecondDiskToInstanceReturns.result1
}

func (fake *FakeClient) AttachSecondDiskToInstanceCallCount() int {
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	return len(fake.attachSecondDiskToInstanceArgsForCall)
}

func (fake *FakeClient) AttachSecondDiskToInstanceArgsForCall(i int) (int, int) {
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	return fake.attachSecondDiskToInstanceArgsForCall[i].id, fake.attachSecondDiskToInstanceArgsForCall[i].diskSize
}

func (fake *FakeClient) AttachSecondDiskToInstanceReturns(result1 error) {
	fake.AttachSecondDiskToInstanceStub = nil
	fake.attachSecondDiskToInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AttachSecondDiskToInstanceReturnsOnCall(i int, result1 error) {
	fake.AttachSecondDiskToInstanceStub = nil
	if fake.attachSecondDiskToInstanceReturnsOnCall == nil {
		fake.attachSecondDiskToInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachSecondDiskToInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetInstanceAllowedHost(id int) (datatypes.Network_Storage_Allowed_Host, error) {
	fake.getInstanceAllowedHostMutex.Lock()
	ret, specificReturn := fake.getInstanceAllowedHostReturnsOnCall[len(fake.getInstanceAllowedHostArgsForCall)]
	fake.getInstanceAllowedHostArgsForCall = append(fake.getInstanceAllowedHostArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetInstanceAllowedHost", []interface{}{id})
	fake.getInstanceAllowedHostMutex.Unlock()
	if fake.GetInstanceAllowedHostStub != nil {
		return fake.GetInstanceAllowedHostStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getInstanceAllowedHostReturns.result1, fake.getInstanceAllowedHostReturns.result2
}

func (fake *FakeClient) GetInstanceAllowedHostCallCount() int {
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	return len(fake.getInstanceAllowedHostArgsForCall)
}

func (fake *FakeClient) GetInstanceAllowedHostArgsForCall(i int) int {
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	return fake.getInstanceAllowedHostArgsForCall[i].id
}

func (fake *FakeClient) GetInstanceAllowedHostReturns(result1 datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.GetInstanceAllowedHostStub = nil
	fake.getInstanceAllowedHostReturns = struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceAllowedHostReturnsOnCall(i int, result1 datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.GetInstanceAllowedHostStub = nil
	if fake.getInstanceAllowedHostReturnsOnCall == nil {
		fake.getInstanceAllowedHostReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage_Allowed_Host
			result2 error
		})
	}
	fake.getInstanceAllowedHostReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AuthorizeHostToVolume(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) error {
	fake.authorizeHostToVolumeMutex.Lock()
	ret, specificReturn := fake.authorizeHostToVolumeReturnsOnCall[len(fake.authorizeHostToVolumeArgsForCall)]
	fake.authorizeHostToVolumeArgsForCall = append(fake.authorizeHostToVolumeArgsForCall, struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}{instance, volumeId, until})
	fake.recordInvocation("AuthorizeHostToVolume", []interface{}{instance, volumeId, until})
	fake.authorizeHostToVolumeMutex.Unlock()
	if fake.AuthorizeHostToVolumeStub != nil {
		return fake.AuthorizeHostToVolumeStub(instance, volumeId, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.authorizeHostToVolumeReturns.result1
}

func (fake *FakeClient) AuthorizeHostToVolumeCallCount() int {
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	return len(fake.authorizeHostToVolumeArgsForCall)
}

func (fake *FakeClient) AuthorizeHostToVolumeArgsForCall(i int) (*datatypes.Virtual_Guest, int, time.Time) {
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	return fake.authorizeHostToVolumeArgsForCall[i].instance, fake.authorizeHostToVolumeArgsForCall[i].volumeId, fake.authorizeHostToVolumeArgsForCall[i].until
}

func (fake *FakeClient) AuthorizeHostToVolumeReturns(result1 error) {
	fake.AuthorizeHostToVolumeStub = nil
	fake.authorizeHostToVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AuthorizeHostToVolumeReturnsOnCall(i int, result1 error) {
	fake.AuthorizeHostToVolumeStub = nil
	if fake.authorizeHostToVolumeReturnsOnCall == nil {
		fake.authorizeHostToVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.authorizeHostToVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeauthorizeHostToVolume(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) error {
	fake.deauthorizeHostToVolumeMutex.Lock()
	ret, specificReturn := fake.deauthorizeHostToVolumeReturnsOnCall[len(fake.deauthorizeHostToVolumeArgsForCall)]
	fake.deauthorizeHostToVolumeArgsForCall = append(fake.deauthorizeHostToVolumeArgsForCall, struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}{instance, volumeId, until})
	fake.recordInvocation("DeauthorizeHostToVolume", []interface{}{instance, volumeId, until})
	fake.deauthorizeHostToVolumeMutex.Unlock()
	if fake.DeauthorizeHostToVolumeStub != nil {
		return fake.DeauthorizeHostToVolumeStub(instance, volumeId, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deauthorizeHostToVolumeReturns.result1
}

func (fake *FakeClient) DeauthorizeHostToVolumeCallCount() int {
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	return len(fake.deauthorizeHostToVolumeArgsForCall)
}

func (fake *FakeClient) DeauthorizeHostToVolumeArgsForCall(i int) (*datatypes.Virtual_Guest, int, time.Time) {
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	return fake.deauthorizeHostToVolumeArgsForCall[i].instance, fake.deauthorizeHostToVolumeArgsForCall[i].volumeId, fake.deauthorizeHostToVolumeArgsForCall[i].until
}

func (fake *FakeClient) DeauthorizeHostToVolumeReturns(result1 error) {
	fake.DeauthorizeHostToVolumeStub = nil
	fake.deauthorizeHostToVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeauthorizeHostToVolumeReturnsOnCall(i int, result1 error) {
	fake.DeauthorizeHostToVolumeStub = nil
	if fake.deauthorizeHostToVolumeReturnsOnCall == nil {
		fake.deauthorizeHostToVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deauthorizeHostToVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateVolume(location string, size int, iops int) (datatypes.Network_Storage, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		location string
		size     int
		iops     int
	}{location, size, iops})
	fake.recordInvocation("CreateVolume", []interface{}{location, size, iops})
	fake.createVolumeMutex.Unlock()
	if fake.CreateVolumeStub != nil {
		return fake.CreateVolumeStub(location, size, iops)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createVolumeReturns.result1, fake.createVolumeReturns.result2
}

func (fake *FakeClient) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeClient) CreateVolumeArgsForCall(i int) (string, int, int) {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return fake.createVolumeArgsForCall[i].location, fake.createVolumeArgsForCall[i].size, fake.createVolumeArgsForCall[i].iops
}

func (fake *FakeClient) CreateVolumeReturns(result1 datatypes.Network_Storage, result2 error) {
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateVolumeReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 error) {
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OrderBlockVolume(storageType string, location string, size int, iops int) (datatypes.Container_Product_Order_Receipt, error) {
	fake.orderBlockVolumeMutex.Lock()
	ret, specificReturn := fake.orderBlockVolumeReturnsOnCall[len(fake.orderBlockVolumeArgsForCall)]
	fake.orderBlockVolumeArgsForCall = append(fake.orderBlockVolumeArgsForCall, struct {
		storageType string
		location    string
		size        int
		iops        int
	}{storageType, location, size, iops})
	fake.recordInvocation("OrderBlockVolume", []interface{}{storageType, location, size, iops})
	fake.orderBlockVolumeMutex.Unlock()
	if fake.OrderBlockVolumeStub != nil {
		return fake.OrderBlockVolumeStub(storageType, location, size, iops)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.orderBlockVolumeReturns.result1, fake.orderBlockVolumeReturns.result2
}

func (fake *FakeClient) OrderBlockVolumeCallCount() int {
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	return len(fake.orderBlockVolumeArgsForCall)
}

func (fake *FakeClient) OrderBlockVolumeArgsForCall(i int) (string, string, int, int) {
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	return fake.orderBlockVolumeArgsForCall[i].storageType, fake.orderBlockVolumeArgsForCall[i].location, fake.orderBlockVolumeArgsForCall[i].size, fake.orderBlockVolumeArgsForCall[i].iops
}

func (fake *FakeClient) OrderBlockVolumeReturns(result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.OrderBlockVolumeStub = nil
	fake.orderBlockVolumeReturns = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OrderBlockVolumeReturnsOnCall(i int, result1 datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.OrderBlockVolumeStub = nil
	if fake.orderBlockVolumeReturnsOnCall == nil {
		fake.orderBlockVolumeReturnsOnCall = make(map[int]struct {
			result1 datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderBlockVolumeReturnsOnCall[i] = struct {
		result1 datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CancelBlockVolume(volumeId int, reason string, immedicate bool) error {
	fake.cancelBlockVolumeMutex.Lock()
	ret, specificReturn := fake.cancelBlockVolumeReturnsOnCall[len(fake.cancelBlockVolumeArgsForCall)]
	fake.cancelBlockVolumeArgsForCall = append(fake.cancelBlockVolumeArgsForCall, struct {
		volumeId   int
		reason     string
		immedicate bool
	}{volumeId, reason, immedicate})
	fake.recordInvocation("CancelBlockVolume", []interface{}{volumeId, reason, immedicate})
	fake.cancelBlockVolumeMutex.Unlock()
	if fake.CancelBlockVolumeStub != nil {
		return fake.CancelBlockVolumeStub(volumeId, reason, immedicate)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cancelBlockVolumeReturns.result1
}

func (fake *FakeClient) CancelBlockVolumeCallCount() int {
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	return len(fake.cancelBlockVolumeArgsForCall)
}

func (fake *FakeClient) CancelBlockVolumeArgsForCall(i int) (int, string, bool) {
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	return fake.cancelBlockVolumeArgsForCall[i].volumeId, fake.cancelBlockVolumeArgsForCall[i].reason, fake.cancelBlockVolumeArgsForCall[i].immedicate
}

func (fake *FakeClient) CancelBlockVolumeReturns(result1 error) {
	fake.CancelBlockVolumeStub = nil
	fake.cancelBlockVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CancelBlockVolumeReturnsOnCall(i int, result1 error) {
	fake.CancelBlockVolumeStub = nil
	if fake.cancelBlockVolumeReturnsOnCall == nil {
		fake.cancelBlockVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelBlockVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetBlockVolumeDetails(volumeId int, mask string) (datatypes.Network_Storage, error) {
	fake.getBlockVolumeDetailsMutex.Lock()
	ret, specificReturn := fake.getBlockVolumeDetailsReturnsOnCall[len(fake.getBlockVolumeDetailsArgsForCall)]
	fake.getBlockVolumeDetailsArgsForCall = append(fake.getBlockVolumeDetailsArgsForCall, struct {
		volumeId int
		mask     string
	}{volumeId, mask})
	fake.recordInvocation("GetBlockVolumeDetails", []interface{}{volumeId, mask})
	fake.getBlockVolumeDetailsMutex.Unlock()
	if fake.GetBlockVolumeDetailsStub != nil {
		return fake.GetBlockVolumeDetailsStub(volumeId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBlockVolumeDetailsReturns.result1, fake.getBlockVolumeDetailsReturns.result2
}

func (fake *FakeClient) GetBlockVolumeDetailsCallCount() int {
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	return len(fake.getBlockVolumeDetailsArgsForCall)
}

func (fake *FakeClient) GetBlockVolumeDetailsArgsForCall(i int) (int, string) {
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	return fake.getBlockVolumeDetailsArgsForCall[i].volumeId, fake.getBlockVolumeDetailsArgsForCall[i].mask
}

func (fake *FakeClient) GetBlockVolumeDetailsReturns(result1 datatypes.Network_Storage, result2 error) {
	fake.GetBlockVolumeDetailsStub = nil
	fake.getBlockVolumeDetailsReturns = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBlockVolumeDetailsReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 error) {
	fake.GetBlockVolumeDetailsStub = nil
	if fake.getBlockVolumeDetailsReturnsOnCall == nil {
		fake.getBlockVolumeDetailsReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 error
		})
	}
	fake.getBlockVolumeDetailsReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetImage(imageId int, mask string) (datatypes.Virtual_Guest_Block_Device_Template_Group, error) {
	fake.getImageMutex.Lock()
	ret, specificReturn := fake.getImageReturnsOnCall[len(fake.getImageArgsForCall)]
	fake.getImageArgsForCall = append(fake.getImageArgsForCall, struct {
		imageId int
		mask    string
	}{imageId, mask})
	fake.recordInvocation("GetImage", []interface{}{imageId, mask})
	fake.getImageMutex.Unlock()
	if fake.GetImageStub != nil {
		return fake.GetImageStub(imageId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getImageReturns.result1, fake.getImageReturns.result2
}

func (fake *FakeClient) GetImageCallCount() int {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	return len(fake.getImageArgsForCall)
}

func (fake *FakeClient) GetImageArgsForCall(i int) (int, string) {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	return fake.getImageArgsForCall[i].imageId, fake.getImageArgsForCall[i].mask
}

func (fake *FakeClient) GetImageReturns(result1 datatypes.Virtual_Guest_Block_Device_Template_Group, result2 error) {
	fake.GetImageStub = nil
	fake.getImageReturns = struct {
		result1 datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetImageReturnsOnCall(i int, result1 datatypes.Virtual_Guest_Block_Device_Template_Group, result2 error) {
	fake.GetImageStub = nil
	if fake.getImageReturnsOnCall == nil {
		fake.getImageReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest_Block_Device_Template_Group
			result2 error
		})
	}
	fake.getImageReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetVlan(id int, mask string) (datatypes.Network_Vlan, error) {
	fake.getVlanMutex.Lock()
	ret, specificReturn := fake.getVlanReturnsOnCall[len(fake.getVlanArgsForCall)]
	fake.getVlanArgsForCall = append(fake.getVlanArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetVlan", []interface{}{id, mask})
	fake.getVlanMutex.Unlock()
	if fake.GetVlanStub != nil {
		return fake.GetVlanStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVlanReturns.result1, fake.getVlanReturns.result2
}

func (fake *FakeClient) GetVlanCallCount() int {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return len(fake.getVlanArgsForCall)
}

func (fake *FakeClient) GetVlanArgsForCall(i int) (int, string) {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return fake.getVlanArgsForCall[i].id, fake.getVlanArgsForCall[i].mask
}

func (fake *FakeClient) GetVlanReturns(result1 datatypes.Network_Vlan, result2 error) {
	fake.GetVlanStub = nil
	fake.getVlanReturns = struct {
		result1 datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetVlanReturnsOnCall(i int, result1 datatypes.Network_Vlan, result2 error) {
	fake.GetVlanStub = nil
	if fake.getVlanReturnsOnCall == nil {
		fake.getVlanReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Vlan
			result2 error
		})
	}
	fake.getVlanReturnsOnCall[i] = struct {
		result1 datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAllowedHostCredential(id int) (datatypes.Network_Storage_Allowed_Host, error) {
	fake.getAllowedHostCredentialMutex.Lock()
	ret, specificReturn := fake.getAllowedHostCredentialReturnsOnCall[len(fake.getAllowedHostCredentialArgsForCall)]
	fake.getAllowedHostCredentialArgsForCall = append(fake.getAllowedHostCredentialArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetAllowedHostCredential", []interface{}{id})
	fake.getAllowedHostCredentialMutex.Unlock()
	if fake.GetAllowedHostCredentialStub != nil {
		return fake.GetAllowedHostCredentialStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAllowedHostCredentialReturns.result1, fake.getAllowedHostCredentialReturns.result2
}

func (fake *FakeClient) GetAllowedHostCredentialCallCount() int {
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	return len(fake.getAllowedHostCredentialArgsForCall)
}

func (fake *FakeClient) GetAllowedHostCredentialArgsForCall(i int) int {
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	return fake.getAllowedHostCredentialArgsForCall[i].id
}

func (fake *FakeClient) GetAllowedHostCredentialReturns(result1 datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.GetAllowedHostCredentialStub = nil
	fake.getAllowedHostCredentialReturns = struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAllowedHostCredentialReturnsOnCall(i int, result1 datatypes.Network_Storage_Allowed_Host, result2 error) {
	fake.GetAllowedHostCredentialStub = nil
	if fake.getAllowedHostCredentialReturnsOnCall == nil {
		fake.getAllowedHostCredentialReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage_Allowed_Host
			result2 error
		})
	}
	fake.getAllowedHostCredentialReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage_Allowed_Host
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAllowedNetworkStorage(id int) ([]string, error) {
	fake.getAllowedNetworkStorageMutex.Lock()
	ret, specificReturn := fake.getAllowedNetworkStorageReturnsOnCall[len(fake.getAllowedNetworkStorageArgsForCall)]
	fake.getAllowedNetworkStorageArgsForCall = append(fake.getAllowedNetworkStorageArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetAllowedNetworkStorage", []interface{}{id})
	fake.getAllowedNetworkStorageMutex.Unlock()
	if fake.GetAllowedNetworkStorageStub != nil {
		return fake.GetAllowedNetworkStorageStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAllowedNetworkStorageReturns.result1, fake.getAllowedNetworkStorageReturns.result2
}

func (fake *FakeClient) GetAllowedNetworkStorageCallCount() int {
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	return len(fake.getAllowedNetworkStorageArgsForCall)
}

func (fake *FakeClient) GetAllowedNetworkStorageArgsForCall(i int) int {
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	return fake.getAllowedNetworkStorageArgsForCall[i].id
}

func (fake *FakeClient) GetAllowedNetworkStorageReturns(result1 []string, result2 error) {
	fake.GetAllowedNetworkStorageStub = nil
	fake.getAllowedNetworkStorageReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAllowedNetworkStorageReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetAllowedNetworkStorageStub = nil
	if fake.getAllowedNetworkStorageReturnsOnCall == nil {
		fake.getAllowedNetworkStorageReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getAllowedNetworkStorageReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
