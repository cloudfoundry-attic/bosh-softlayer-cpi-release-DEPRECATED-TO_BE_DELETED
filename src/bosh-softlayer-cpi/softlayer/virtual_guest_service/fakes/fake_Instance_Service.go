// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	instance "bosh-softlayer-cpi/softlayer/virtual_guest_service"
	"sync"

	"github.com/softlayer/softlayer-go/datatypes"
)

type FakeService struct {
	AttachDiskStub        func(id int, diskID int) (string, string, error)
	attachDiskMutex       sync.RWMutex
	attachDiskArgsForCall []struct {
		id     int
		diskID int
	}
	attachDiskReturns struct {
		result1 string
		result2 string
		result3 error
	}
	attachDiskReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	AttachedDisksStub        func(id int) ([]string, error)
	attachedDisksMutex       sync.RWMutex
	attachedDisksArgsForCall []struct {
		id int
	}
	attachedDisksReturns struct {
		result1 []string
		result2 error
	}
	attachedDisksReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	AttachEphemeralDiskStub        func(id int, diskSize int) error
	attachEphemeralDiskMutex       sync.RWMutex
	attachEphemeralDiskArgsForCall []struct {
		id       int
		diskSize int
	}
	attachEphemeralDiskReturns struct {
		result1 error
	}
	attachEphemeralDiskReturnsOnCall map[int]struct {
		result1 error
	}
	CreateStub        func(vmProps *instance.Properties, networks instance.Networks, registryEndpoint string) (int, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		vmProps          *instance.Properties
		networks         instance.Networks
		registryEndpoint string
	}
	createReturns struct {
		result1 int
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ConfigureNetworksStub        func(id int, networks instance.Networks) (instance.Networks, error)
	configureNetworksMutex       sync.RWMutex
	configureNetworksArgsForCall []struct {
		id       int
		networks instance.Networks
	}
	configureNetworksReturns struct {
		result1 instance.Networks
		result2 error
	}
	configureNetworksReturnsOnCall map[int]struct {
		result1 instance.Networks
		result2 error
	}
	CleanUpStub        func(id int)
	cleanUpMutex       sync.RWMutex
	cleanUpArgsForCall []struct {
		id int
	}
	DeleteStub        func(id int) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		id int
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DetachDiskStub        func(id int, diskID int) error
	detachDiskMutex       sync.RWMutex
	detachDiskArgsForCall []struct {
		id     int
		diskID int
	}
	detachDiskReturns struct {
		result1 error
	}
	detachDiskReturnsOnCall map[int]struct {
		result1 error
	}
	EditStub        func(id int, instance datatypes.Virtual_Guest) (bool, error)
	editMutex       sync.RWMutex
	editArgsForCall []struct {
		id       int
		instance datatypes.Virtual_Guest
	}
	editReturns struct {
		result1 bool
		result2 error
	}
	editReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FindStub        func(id int) (datatypes.Virtual_Guest, bool, error)
	findMutex       sync.RWMutex
	findArgsForCall []struct {
		id int
	}
	findReturns struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	findReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	FindByPrimaryBackendIpStub        func(ip string) (datatypes.Virtual_Guest, bool, error)
	findByPrimaryBackendIpMutex       sync.RWMutex
	findByPrimaryBackendIpArgsForCall []struct {
		ip string
	}
	findByPrimaryBackendIpReturns struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	findByPrimaryBackendIpReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	FindByPrimaryIpStub        func(ip string) (datatypes.Virtual_Guest, bool, error)
	findByPrimaryIpMutex       sync.RWMutex
	findByPrimaryIpArgsForCall []struct {
		ip string
	}
	findByPrimaryIpReturns struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	findByPrimaryIpReturnsOnCall map[int]struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	GetVlanStub        func(id int, mask string) (datatypes.Network_Vlan, error)
	getVlanMutex       sync.RWMutex
	getVlanArgsForCall []struct {
		id   int
		mask string
	}
	getVlanReturns struct {
		result1 datatypes.Network_Vlan
		result2 error
	}
	getVlanReturnsOnCall map[int]struct {
		result1 datatypes.Network_Vlan
		result2 error
	}
	ReAttachLeftDiskStub        func(id int, devicePath string, diskID int) error
	reAttachLeftDiskMutex       sync.RWMutex
	reAttachLeftDiskArgsForCall []struct {
		id         int
		devicePath string
		diskID     int
	}
	reAttachLeftDiskReturns struct {
		result1 error
	}
	reAttachLeftDiskReturnsOnCall map[int]struct {
		result1 error
	}
	RebootStub        func(id int) error
	rebootMutex       sync.RWMutex
	rebootArgsForCall []struct {
		id int
	}
	rebootReturns struct {
		result1 error
	}
	rebootReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadOSStub        func(id int, stemcellID int, sshKeyIds []int) (string, error)
	reloadOSMutex       sync.RWMutex
	reloadOSArgsForCall []struct {
		id         int
		stemcellID int
		sshKeyIds  []int
	}
	reloadOSReturns struct {
		result1 string
		result2 error
	}
	reloadOSReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetMetadataStub        func(id int, vmMetadata instance.Metadata) error
	setMetadataMutex       sync.RWMutex
	setMetadataArgsForCall []struct {
		id         int
		vmMetadata instance.Metadata
	}
	setMetadataReturns struct {
		result1 error
	}
	setMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeService) AttachDisk(id int, diskID int) (string, string, error) {
	fake.attachDiskMutex.Lock()
	ret, specificReturn := fake.attachDiskReturnsOnCall[len(fake.attachDiskArgsForCall)]
	fake.attachDiskArgsForCall = append(fake.attachDiskArgsForCall, struct {
		id     int
		diskID int
	}{id, diskID})
	fake.recordInvocation("AttachDisk", []interface{}{id, diskID})
	fake.attachDiskMutex.Unlock()
	if fake.AttachDiskStub != nil {
		return fake.AttachDiskStub(id, diskID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.attachDiskReturns.result1, fake.attachDiskReturns.result2, fake.attachDiskReturns.result3
}

func (fake *FakeService) AttachDiskCallCount() int {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return len(fake.attachDiskArgsForCall)
}

func (fake *FakeService) AttachDiskArgsForCall(i int) (int, int) {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return fake.attachDiskArgsForCall[i].id, fake.attachDiskArgsForCall[i].diskID
}

func (fake *FakeService) AttachDiskReturns(result1 string, result2 string, result3 error) {
	fake.AttachDiskStub = nil
	fake.attachDiskReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) AttachDiskReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.AttachDiskStub = nil
	if fake.attachDiskReturnsOnCall == nil {
		fake.attachDiskReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.attachDiskReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) AttachedDisks(id int) ([]string, error) {
	fake.attachedDisksMutex.Lock()
	ret, specificReturn := fake.attachedDisksReturnsOnCall[len(fake.attachedDisksArgsForCall)]
	fake.attachedDisksArgsForCall = append(fake.attachedDisksArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("AttachedDisks", []interface{}{id})
	fake.attachedDisksMutex.Unlock()
	if fake.AttachedDisksStub != nil {
		return fake.AttachedDisksStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.attachedDisksReturns.result1, fake.attachedDisksReturns.result2
}

func (fake *FakeService) AttachedDisksCallCount() int {
	fake.attachedDisksMutex.RLock()
	defer fake.attachedDisksMutex.RUnlock()
	return len(fake.attachedDisksArgsForCall)
}

func (fake *FakeService) AttachedDisksArgsForCall(i int) int {
	fake.attachedDisksMutex.RLock()
	defer fake.attachedDisksMutex.RUnlock()
	return fake.attachedDisksArgsForCall[i].id
}

func (fake *FakeService) AttachedDisksReturns(result1 []string, result2 error) {
	fake.AttachedDisksStub = nil
	fake.attachedDisksReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) AttachedDisksReturnsOnCall(i int, result1 []string, result2 error) {
	fake.AttachedDisksStub = nil
	if fake.attachedDisksReturnsOnCall == nil {
		fake.attachedDisksReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.attachedDisksReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) AttachEphemeralDisk(id int, diskSize int) error {
	fake.attachEphemeralDiskMutex.Lock()
	ret, specificReturn := fake.attachEphemeralDiskReturnsOnCall[len(fake.attachEphemeralDiskArgsForCall)]
	fake.attachEphemeralDiskArgsForCall = append(fake.attachEphemeralDiskArgsForCall, struct {
		id       int
		diskSize int
	}{id, diskSize})
	fake.recordInvocation("AttachEphemeralDisk", []interface{}{id, diskSize})
	fake.attachEphemeralDiskMutex.Unlock()
	if fake.AttachEphemeralDiskStub != nil {
		return fake.AttachEphemeralDiskStub(id, diskSize)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachEphemeralDiskReturns.result1
}

func (fake *FakeService) AttachEphemeralDiskCallCount() int {
	fake.attachEphemeralDiskMutex.RLock()
	defer fake.attachEphemeralDiskMutex.RUnlock()
	return len(fake.attachEphemeralDiskArgsForCall)
}

func (fake *FakeService) AttachEphemeralDiskArgsForCall(i int) (int, int) {
	fake.attachEphemeralDiskMutex.RLock()
	defer fake.attachEphemeralDiskMutex.RUnlock()
	return fake.attachEphemeralDiskArgsForCall[i].id, fake.attachEphemeralDiskArgsForCall[i].diskSize
}

func (fake *FakeService) AttachEphemeralDiskReturns(result1 error) {
	fake.AttachEphemeralDiskStub = nil
	fake.attachEphemeralDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) AttachEphemeralDiskReturnsOnCall(i int, result1 error) {
	fake.AttachEphemeralDiskStub = nil
	if fake.attachEphemeralDiskReturnsOnCall == nil {
		fake.attachEphemeralDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachEphemeralDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Create(vmProps *instance.Properties, networks instance.Networks, registryEndpoint string) (int, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		vmProps          *instance.Properties
		networks         instance.Networks
		registryEndpoint string
	}{vmProps, networks, registryEndpoint})
	fake.recordInvocation("Create", []interface{}{vmProps, networks, registryEndpoint})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(vmProps, networks, registryEndpoint)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeService) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeService) CreateArgsForCall(i int) (*instance.Properties, instance.Networks, string) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].vmProps, fake.createArgsForCall[i].networks, fake.createArgsForCall[i].registryEndpoint
}

func (fake *FakeService) CreateReturns(result1 int, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeService) CreateReturnsOnCall(i int, result1 int, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeService) ConfigureNetworks(id int, networks instance.Networks) (instance.Networks, error) {
	fake.configureNetworksMutex.Lock()
	ret, specificReturn := fake.configureNetworksReturnsOnCall[len(fake.configureNetworksArgsForCall)]
	fake.configureNetworksArgsForCall = append(fake.configureNetworksArgsForCall, struct {
		id       int
		networks instance.Networks
	}{id, networks})
	fake.recordInvocation("ConfigureNetworks", []interface{}{id, networks})
	fake.configureNetworksMutex.Unlock()
	if fake.ConfigureNetworksStub != nil {
		return fake.ConfigureNetworksStub(id, networks)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.configureNetworksReturns.result1, fake.configureNetworksReturns.result2
}

func (fake *FakeService) ConfigureNetworksCallCount() int {
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	return len(fake.configureNetworksArgsForCall)
}

func (fake *FakeService) ConfigureNetworksArgsForCall(i int) (int, instance.Networks) {
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	return fake.configureNetworksArgsForCall[i].id, fake.configureNetworksArgsForCall[i].networks
}

func (fake *FakeService) ConfigureNetworksReturns(result1 instance.Networks, result2 error) {
	fake.ConfigureNetworksStub = nil
	fake.configureNetworksReturns = struct {
		result1 instance.Networks
		result2 error
	}{result1, result2}
}

func (fake *FakeService) ConfigureNetworksReturnsOnCall(i int, result1 instance.Networks, result2 error) {
	fake.ConfigureNetworksStub = nil
	if fake.configureNetworksReturnsOnCall == nil {
		fake.configureNetworksReturnsOnCall = make(map[int]struct {
			result1 instance.Networks
			result2 error
		})
	}
	fake.configureNetworksReturnsOnCall[i] = struct {
		result1 instance.Networks
		result2 error
	}{result1, result2}
}

func (fake *FakeService) CleanUp(id int) {
	fake.cleanUpMutex.Lock()
	fake.cleanUpArgsForCall = append(fake.cleanUpArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("CleanUp", []interface{}{id})
	fake.cleanUpMutex.Unlock()
	if fake.CleanUpStub != nil {
		fake.CleanUpStub(id)
	}
}

func (fake *FakeService) CleanUpCallCount() int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return len(fake.cleanUpArgsForCall)
}

func (fake *FakeService) CleanUpArgsForCall(i int) int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return fake.cleanUpArgsForCall[i].id
}

func (fake *FakeService) Delete(id int) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("Delete", []interface{}{id})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeService) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeService) DeleteArgsForCall(i int) int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].id
}

func (fake *FakeService) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DetachDisk(id int, diskID int) error {
	fake.detachDiskMutex.Lock()
	ret, specificReturn := fake.detachDiskReturnsOnCall[len(fake.detachDiskArgsForCall)]
	fake.detachDiskArgsForCall = append(fake.detachDiskArgsForCall, struct {
		id     int
		diskID int
	}{id, diskID})
	fake.recordInvocation("DetachDisk", []interface{}{id, diskID})
	fake.detachDiskMutex.Unlock()
	if fake.DetachDiskStub != nil {
		return fake.DetachDiskStub(id, diskID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.detachDiskReturns.result1
}

func (fake *FakeService) DetachDiskCallCount() int {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return len(fake.detachDiskArgsForCall)
}

func (fake *FakeService) DetachDiskArgsForCall(i int) (int, int) {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return fake.detachDiskArgsForCall[i].id, fake.detachDiskArgsForCall[i].diskID
}

func (fake *FakeService) DetachDiskReturns(result1 error) {
	fake.DetachDiskStub = nil
	fake.detachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DetachDiskReturnsOnCall(i int, result1 error) {
	fake.DetachDiskStub = nil
	if fake.detachDiskReturnsOnCall == nil {
		fake.detachDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Edit(id int, instance datatypes.Virtual_Guest) (bool, error) {
	fake.editMutex.Lock()
	ret, specificReturn := fake.editReturnsOnCall[len(fake.editArgsForCall)]
	fake.editArgsForCall = append(fake.editArgsForCall, struct {
		id       int
		instance datatypes.Virtual_Guest
	}{id, instance})
	fake.recordInvocation("Edit", []interface{}{id, instance})
	fake.editMutex.Unlock()
	if fake.EditStub != nil {
		return fake.EditStub(id, instance)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.editReturns.result1, fake.editReturns.result2
}

func (fake *FakeService) EditCallCount() int {
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	return len(fake.editArgsForCall)
}

func (fake *FakeService) EditArgsForCall(i int) (int, datatypes.Virtual_Guest) {
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	return fake.editArgsForCall[i].id, fake.editArgsForCall[i].instance
}

func (fake *FakeService) EditReturns(result1 bool, result2 error) {
	fake.EditStub = nil
	fake.editReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeService) EditReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EditStub = nil
	if fake.editReturnsOnCall == nil {
		fake.editReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.editReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeService) Find(id int) (datatypes.Virtual_Guest, bool, error) {
	fake.findMutex.Lock()
	ret, specificReturn := fake.findReturnsOnCall[len(fake.findArgsForCall)]
	fake.findArgsForCall = append(fake.findArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("Find", []interface{}{id})
	fake.findMutex.Unlock()
	if fake.FindStub != nil {
		return fake.FindStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findReturns.result1, fake.findReturns.result2, fake.findReturns.result3
}

func (fake *FakeService) FindCallCount() int {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return len(fake.findArgsForCall)
}

func (fake *FakeService) FindArgsForCall(i int) int {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return fake.findArgsForCall[i].id
}

func (fake *FakeService) FindReturns(result1 datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.FindStub = nil
	fake.findReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) FindReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.FindStub = nil
	if fake.findReturnsOnCall == nil {
		fake.findReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.findReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) FindByPrimaryBackendIp(ip string) (datatypes.Virtual_Guest, bool, error) {
	fake.findByPrimaryBackendIpMutex.Lock()
	ret, specificReturn := fake.findByPrimaryBackendIpReturnsOnCall[len(fake.findByPrimaryBackendIpArgsForCall)]
	fake.findByPrimaryBackendIpArgsForCall = append(fake.findByPrimaryBackendIpArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("FindByPrimaryBackendIp", []interface{}{ip})
	fake.findByPrimaryBackendIpMutex.Unlock()
	if fake.FindByPrimaryBackendIpStub != nil {
		return fake.FindByPrimaryBackendIpStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findByPrimaryBackendIpReturns.result1, fake.findByPrimaryBackendIpReturns.result2, fake.findByPrimaryBackendIpReturns.result3
}

func (fake *FakeService) FindByPrimaryBackendIpCallCount() int {
	fake.findByPrimaryBackendIpMutex.RLock()
	defer fake.findByPrimaryBackendIpMutex.RUnlock()
	return len(fake.findByPrimaryBackendIpArgsForCall)
}

func (fake *FakeService) FindByPrimaryBackendIpArgsForCall(i int) string {
	fake.findByPrimaryBackendIpMutex.RLock()
	defer fake.findByPrimaryBackendIpMutex.RUnlock()
	return fake.findByPrimaryBackendIpArgsForCall[i].ip
}

func (fake *FakeService) FindByPrimaryBackendIpReturns(result1 datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.FindByPrimaryBackendIpStub = nil
	fake.findByPrimaryBackendIpReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) FindByPrimaryBackendIpReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.FindByPrimaryBackendIpStub = nil
	if fake.findByPrimaryBackendIpReturnsOnCall == nil {
		fake.findByPrimaryBackendIpReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.findByPrimaryBackendIpReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) FindByPrimaryIp(ip string) (datatypes.Virtual_Guest, bool, error) {
	fake.findByPrimaryIpMutex.Lock()
	ret, specificReturn := fake.findByPrimaryIpReturnsOnCall[len(fake.findByPrimaryIpArgsForCall)]
	fake.findByPrimaryIpArgsForCall = append(fake.findByPrimaryIpArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("FindByPrimaryIp", []interface{}{ip})
	fake.findByPrimaryIpMutex.Unlock()
	if fake.FindByPrimaryIpStub != nil {
		return fake.FindByPrimaryIpStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findByPrimaryIpReturns.result1, fake.findByPrimaryIpReturns.result2, fake.findByPrimaryIpReturns.result3
}

func (fake *FakeService) FindByPrimaryIpCallCount() int {
	fake.findByPrimaryIpMutex.RLock()
	defer fake.findByPrimaryIpMutex.RUnlock()
	return len(fake.findByPrimaryIpArgsForCall)
}

func (fake *FakeService) FindByPrimaryIpArgsForCall(i int) string {
	fake.findByPrimaryIpMutex.RLock()
	defer fake.findByPrimaryIpMutex.RUnlock()
	return fake.findByPrimaryIpArgsForCall[i].ip
}

func (fake *FakeService) FindByPrimaryIpReturns(result1 datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.FindByPrimaryIpStub = nil
	fake.findByPrimaryIpReturns = struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) FindByPrimaryIpReturnsOnCall(i int, result1 datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.FindByPrimaryIpStub = nil
	if fake.findByPrimaryIpReturnsOnCall == nil {
		fake.findByPrimaryIpReturnsOnCall = make(map[int]struct {
			result1 datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.findByPrimaryIpReturnsOnCall[i] = struct {
		result1 datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) GetVlan(id int, mask string) (datatypes.Network_Vlan, error) {
	fake.getVlanMutex.Lock()
	ret, specificReturn := fake.getVlanReturnsOnCall[len(fake.getVlanArgsForCall)]
	fake.getVlanArgsForCall = append(fake.getVlanArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetVlan", []interface{}{id, mask})
	fake.getVlanMutex.Unlock()
	if fake.GetVlanStub != nil {
		return fake.GetVlanStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVlanReturns.result1, fake.getVlanReturns.result2
}

func (fake *FakeService) GetVlanCallCount() int {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return len(fake.getVlanArgsForCall)
}

func (fake *FakeService) GetVlanArgsForCall(i int) (int, string) {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return fake.getVlanArgsForCall[i].id, fake.getVlanArgsForCall[i].mask
}

func (fake *FakeService) GetVlanReturns(result1 datatypes.Network_Vlan, result2 error) {
	fake.GetVlanStub = nil
	fake.getVlanReturns = struct {
		result1 datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetVlanReturnsOnCall(i int, result1 datatypes.Network_Vlan, result2 error) {
	fake.GetVlanStub = nil
	if fake.getVlanReturnsOnCall == nil {
		fake.getVlanReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Vlan
			result2 error
		})
	}
	fake.getVlanReturnsOnCall[i] = struct {
		result1 datatypes.Network_Vlan
		result2 error
	}{result1, result2}
}

func (fake *FakeService) ReAttachLeftDisk(id int, devicePath string, diskID int) error {
	fake.reAttachLeftDiskMutex.Lock()
	ret, specificReturn := fake.reAttachLeftDiskReturnsOnCall[len(fake.reAttachLeftDiskArgsForCall)]
	fake.reAttachLeftDiskArgsForCall = append(fake.reAttachLeftDiskArgsForCall, struct {
		id         int
		devicePath string
		diskID     int
	}{id, devicePath, diskID})
	fake.recordInvocation("ReAttachLeftDisk", []interface{}{id, devicePath, diskID})
	fake.reAttachLeftDiskMutex.Unlock()
	if fake.ReAttachLeftDiskStub != nil {
		return fake.ReAttachLeftDiskStub(id, devicePath, diskID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reAttachLeftDiskReturns.result1
}

func (fake *FakeService) ReAttachLeftDiskCallCount() int {
	fake.reAttachLeftDiskMutex.RLock()
	defer fake.reAttachLeftDiskMutex.RUnlock()
	return len(fake.reAttachLeftDiskArgsForCall)
}

func (fake *FakeService) ReAttachLeftDiskArgsForCall(i int) (int, string, int) {
	fake.reAttachLeftDiskMutex.RLock()
	defer fake.reAttachLeftDiskMutex.RUnlock()
	return fake.reAttachLeftDiskArgsForCall[i].id, fake.reAttachLeftDiskArgsForCall[i].devicePath, fake.reAttachLeftDiskArgsForCall[i].diskID
}

func (fake *FakeService) ReAttachLeftDiskReturns(result1 error) {
	fake.ReAttachLeftDiskStub = nil
	fake.reAttachLeftDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) ReAttachLeftDiskReturnsOnCall(i int, result1 error) {
	fake.ReAttachLeftDiskStub = nil
	if fake.reAttachLeftDiskReturnsOnCall == nil {
		fake.reAttachLeftDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reAttachLeftDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Reboot(id int) error {
	fake.rebootMutex.Lock()
	ret, specificReturn := fake.rebootReturnsOnCall[len(fake.rebootArgsForCall)]
	fake.rebootArgsForCall = append(fake.rebootArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("Reboot", []interface{}{id})
	fake.rebootMutex.Unlock()
	if fake.RebootStub != nil {
		return fake.RebootStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rebootReturns.result1
}

func (fake *FakeService) RebootCallCount() int {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	return len(fake.rebootArgsForCall)
}

func (fake *FakeService) RebootArgsForCall(i int) int {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	return fake.rebootArgsForCall[i].id
}

func (fake *FakeService) RebootReturns(result1 error) {
	fake.RebootStub = nil
	fake.rebootReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) RebootReturnsOnCall(i int, result1 error) {
	fake.RebootStub = nil
	if fake.rebootReturnsOnCall == nil {
		fake.rebootReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) ReloadOS(id int, stemcellID int, sshKeyIds []int) (string, error) {
	var sshKeyIdsCopy []int
	if sshKeyIds != nil {
		sshKeyIdsCopy = make([]int, len(sshKeyIds))
		copy(sshKeyIdsCopy, sshKeyIds)
	}
	fake.reloadOSMutex.Lock()
	ret, specificReturn := fake.reloadOSReturnsOnCall[len(fake.reloadOSArgsForCall)]
	fake.reloadOSArgsForCall = append(fake.reloadOSArgsForCall, struct {
		id         int
		stemcellID int
		sshKeyIds  []int
	}{id, stemcellID, sshKeyIdsCopy})
	fake.recordInvocation("ReloadOS", []interface{}{id, stemcellID, sshKeyIdsCopy})
	fake.reloadOSMutex.Unlock()
	if fake.ReloadOSStub != nil {
		return fake.ReloadOSStub(id, stemcellID, sshKeyIds)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.reloadOSReturns.result1, fake.reloadOSReturns.result2
}

func (fake *FakeService) ReloadOSCallCount() int {
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	return len(fake.reloadOSArgsForCall)
}

func (fake *FakeService) ReloadOSArgsForCall(i int) (int, int, []int) {
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	return fake.reloadOSArgsForCall[i].id, fake.reloadOSArgsForCall[i].stemcellID, fake.reloadOSArgsForCall[i].sshKeyIds
}

func (fake *FakeService) ReloadOSReturns(result1 string, result2 error) {
	fake.ReloadOSStub = nil
	fake.reloadOSReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) ReloadOSReturnsOnCall(i int, result1 string, result2 error) {
	fake.ReloadOSStub = nil
	if fake.reloadOSReturnsOnCall == nil {
		fake.reloadOSReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.reloadOSReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) SetMetadata(id int, vmMetadata instance.Metadata) error {
	fake.setMetadataMutex.Lock()
	ret, specificReturn := fake.setMetadataReturnsOnCall[len(fake.setMetadataArgsForCall)]
	fake.setMetadataArgsForCall = append(fake.setMetadataArgsForCall, struct {
		id         int
		vmMetadata instance.Metadata
	}{id, vmMetadata})
	fake.recordInvocation("SetMetadata", []interface{}{id, vmMetadata})
	fake.setMetadataMutex.Unlock()
	if fake.SetMetadataStub != nil {
		return fake.SetMetadataStub(id, vmMetadata)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setMetadataReturns.result1
}

func (fake *FakeService) SetMetadataCallCount() int {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return len(fake.setMetadataArgsForCall)
}

func (fake *FakeService) SetMetadataArgsForCall(i int) (int, instance.Metadata) {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return fake.setMetadataArgsForCall[i].id, fake.setMetadataArgsForCall[i].vmMetadata
}

func (fake *FakeService) SetMetadataReturns(result1 error) {
	fake.SetMetadataStub = nil
	fake.setMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) SetMetadataReturnsOnCall(i int, result1 error) {
	fake.SetMetadataStub = nil
	if fake.setMetadataReturnsOnCall == nil {
		fake.setMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	fake.attachedDisksMutex.RLock()
	defer fake.attachedDisksMutex.RUnlock()
	fake.attachEphemeralDiskMutex.RLock()
	defer fake.attachEphemeralDiskMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	fake.findByPrimaryBackendIpMutex.RLock()
	defer fake.findByPrimaryBackendIpMutex.RUnlock()
	fake.findByPrimaryIpMutex.RLock()
	defer fake.findByPrimaryIpMutex.RUnlock()
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	fake.reAttachLeftDiskMutex.RLock()
	defer fake.reAttachLeftDiskMutex.RUnlock()
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ instance.Service = new(FakeService)
